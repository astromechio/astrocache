package blockchain

import (
	"bytes"
	"crypto/sha256"
	"fmt"

	acrypto "github.com/astromechio/astrocache/crypto"
	"github.com/astromechio/astrocache/model/actions"
	"github.com/pkg/errors"
)

// GenesisBlockID and others are block related consts
const (
	genesisBlockID = "iamthegenesisbutnottheterminator"
)

// Notes:
// ID is the sha256 of the previous block's data
// Data can be anything, but in the context of astrocache, it is generally JSON encrypted by the global symKey
// ActionType is an astrocache specific field to help with unmarshalling
// Signature is a DSS of the data generated by the mining node's privKey
// PrevID is the ID of the block whose data was hashed to create this block's ID (directly previous in the chain)

// Block is the base type for the astrocache blockchain
type Block struct {
	ID         string             `json:"id"`
	Data       *acrypto.Message   `json:"data"`
	ActionType string             `json:"actionType,omitempty"`
	Signature  *acrypto.Signature `json:"signature"`
	PrevID     string             `json:"prevId"`
}

// NewBlockWithAction creates a block with JSON from an action
func NewBlockWithAction(encKey *acrypto.SymKey, action actions.Action) (*Block, error) {
	actionJSON := action.JSON()

	block, err := newBlock(encKey, actionJSON)
	if err != nil {
		return nil, errors.Wrap(err, "NewBlockWithAction failed to NewBlock")
	}

	block.ActionType = action.ActionType()

	return block, nil
}

func genesisBlockWithAction(encKey *acrypto.SymKey, action actions.Action) (*Block, error) {
	actionJSON := action.JSON()

	block, err := newBlock(encKey, actionJSON)
	if err != nil {
		return nil, errors.Wrap(err, "genesisBlockWithAction failed to NewBlock")
	}

	block.ActionType = action.ActionType()

	block.ID = genesisBlockID

	return block, nil
}

func newBlock(encKey *acrypto.SymKey, data []byte) (*Block, error) {
	encData, err := encKey.Encrypt(data)
	if err != nil {
		return nil, err
	}

	newBlock := &Block{
		Data: encData,
	}

	return newBlock, nil
}

// PrepareForCommit prepares a block to be committed
func (b *Block) PrepareForCommit(sigKey *acrypto.KeyPair, prev *Block) error {
	signingBody := []byte{}
	newID := ""
	prevID := ""

	if prev == nil {
		if b.ID != genesisBlockID {
			return errors.New("PrepareForCommit tried to prepare a non-genesis block with a nil prev")
		}

		if sigKey.KID != acrypto.MasterKeyPairKID {
			return fmt.Errorf("PrepareForCommit attempted to prepare a genesis block with a non-master keyPair with KID %s", sigKey.KID)
		}

		signingBody = append([]byte(genesisBlockID), b.Data.Data...)
		newID = b.ID
	} else {
		prevHash, err := prev.Hash()
		if err != nil {
			return errors.Wrap(err, "prepareForCommit failed to prev.Hash")
		}

		signingBody = append(prevHash, b.Data.Data...)
		newID = acrypto.Base64URLEncode(prevHash)
		prevID = prev.ID
	}

	sig, err := sigKey.Sign(signingBody)
	if err != nil {
		return errors.Wrap(err, "prepareForCommit failed to sigKey.Sign")
	}

	b.ID = newID
	b.Signature = sig
	b.PrevID = prevID

	return nil
}

// Verify verifies a block's integrity
func (b *Block) Verify(keySet *acrypto.KeySet, prev *Block) error {
	newID := ""
	signingBody := []byte{}

	sigKey := keySet.KeyPairWithKID(b.Signature.KID)
	if sigKey == nil {
		return fmt.Errorf("Verify unable to find sigKey with KID %s", b.Signature.KID)
	}

	// handle the genesis block case
	if prev == nil {
		if sigKey.KID != acrypto.MasterKeyPairKID {
			return fmt.Errorf("Verify attempted to verify genesis block with non-master keyPair with KID %s", sigKey.KID)
		}

		if b.ID != genesisBlockID {
			return errors.New("Verify attempted to verify non-genesis block with nil prev block")
		}

		signingBody = append([]byte(genesisBlockID), b.Data.Data...)
		newID = genesisBlockID
	} else {
		prevHash, err := prev.Hash()
		if err != nil {
			return errors.Wrap(err, "Verify failed to prev.Hash")
		}

		signingBody = append(prevHash, b.Data.Data...)
		newID = acrypto.Base64URLEncode(prevHash)
	}

	if b.ID != newID {
		return fmt.Errorf("Verify failed, block ID %s does not match prev.Hash %s", b.ID, newID)
	}

	if result := sigKey.Verify(signingBody, b.Signature); result == acrypto.AstroSigUnverified {
		return errors.New("Verify failed to Verify b.Signature")
	}

	return nil
}

// IsSameAsBlock compares one block to another to determine if they are identical
func (b *Block) IsSameAsBlock(b2 *Block) bool {
	if b.ID != b2.ID {
		return false
	}

	bHash, err := b.Hash()
	if err != nil {
		return false
	}

	b2Hash, err := b2.Hash()
	if err != nil {
		return false
	}

	if !bytes.Equal(bHash, b2Hash) {
		return false
	}

	if !bytes.Equal(b.Signature.Signature, b2.Signature.Signature) {
		return false
	}

	return true
}

// Hash computes the sha256 of the block's data
func (b *Block) Hash() ([]byte, error) {
	h := sha256.New()
	_, err := h.Write(b.Data.Data)
	if err != nil {
		return nil, err
	}

	return h.Sum(nil), nil
}
