package blockchain

import (
	"crypto/sha256"
	"fmt"

	acrypto "github.com/astromechio/astrocache/crypto"
	"github.com/astromechio/astrocache/model"
	"github.com/pkg/errors"
)

// Notes:
// ID is the sha256 of the previous block's data
// Data can be anything, but in the context of astrocache, it is generally JSON encrypted by the global symKey
// Signature is a DSS of the data generated by the mining node's privKey
// PrevID is the ID of the block whose data was hashed to create this block's ID (directly previous in the chain)

// Block is the base type for the astrocache blockchain
type Block struct {
	ID        string             `json:"id"`
	Data      *acrypto.Message   `json:"data"`
	Signature *acrypto.Signature `json:"signature"`
	PrevID    string             `json:"prevId"`
}

// NewBlock creates a new block
func NewBlock(sigKey *acrypto.KeyPair, encKey *acrypto.SymKey, data []byte, prev *Block) (*Block, error) {
	newID := ""

	// handle the genesis block case
	if prev == nil {
		if sigKey.KID != acrypto.MasterKeyPairKID {
			return nil, fmt.Errorf("attempted to verify genesis block with non-master keyPair with KID %s", sigKey.KID)
		}

		newID = genesisBlockID
	} else {
		prevHash, err := prev.Hash()
		if err != nil {
			return nil, errors.Wrap(err, "NewBlock failed to prev.Hash")
		}

		newID = acrypto.Base64URLEncode(prevHash)
	}

	encData, err := encKey.Encrypt(data)
	if err != nil {
		return nil, err
	}

	sig, err := sigKey.Sign(encData.Data)
	if err != nil {
		return nil, err
	}

	newBlock := &Block{
		ID:        newID,
		Data:      encData,
		Signature: sig,
		PrevID:    prev.ID,
	}

	return newBlock, nil
}

// NewBlockWithAction creates a block with JSON from an action
func NewBlockWithAction(sigKey *acrypto.KeyPair, encKey *acrypto.SymKey, action model.Action, prev *Block) (*Block, error) {
	actionJSON := action.JSON()

	return NewBlock(sigKey, encKey, actionJSON, prev)
}

// Verify verifies a block's integrity
func (b *Block) Verify(keySet *acrypto.KeySet, prev *Block) error {
	newID := ""

	sigKey := keySet.KeyPairWithKID(b.Signature.KID)
	if sigKey == nil {
		return fmt.Errorf("keyset to verify block signature with KID %s not found", b.Signature.KID)
	}

	// handle the genesis block case
	if prev == nil {
		if sigKey.KID != acrypto.MasterKeyPairKID {
			return fmt.Errorf("attempted to verify genesis block with non-master keyPair with KID %s", sigKey.KID)
		}

		if b.ID != genesisBlockID {
			return errors.New("attempted to verify non-genesis block with nil prev block")
		}

		newID = genesisBlockID
	} else {
		prevHash, err := prev.Hash()
		if err != nil {
			return errors.Wrap(err, "Verify failed to prev.Hash")
		}

		newID = acrypto.Base64URLEncode(prevHash)
	}

	if b.ID != newID {
		return fmt.Errorf("block ID %s does not match prev.Hash %s", b.ID, newID)
	}

	if result := sigKey.Verify(b.Data.Data, b.Signature); result == acrypto.AstroSigUnverified {
		return errors.New("block data verification failed")
	}

	return nil
}

// Hash computes the sha256 of the block's data
func (b *Block) Hash() ([]byte, error) {
	h := sha256.New()
	_, err := h.Write(b.Data.Data)
	if err != nil {
		return nil, err
	}

	return h.Sum(nil), nil
}
